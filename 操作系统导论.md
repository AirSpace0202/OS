#  操作系统概述

## 定义

控制管理计算机系统的硬软件，分配调度资源的**系统软件**

目标：方便性，有效性（提高系统资源利用率），可扩充，开放性

## 基本功能

1、**统一管理计算机资源**

2、**实现对计算机资源的抽象**

3、**提供用户和计算机之间的接口**



# 基本类型

分为批处理系统、分时系统、实时系统



## 基本特征

1、**并行**：两个或多个事件在**同一时刻**发生，多核 CPU 可以实现并行，单核 CPU 同一时刻只有一个程序在运行

2、**并发**：两个或多个事件在**同一时间间隔**发生，每个程序**交替执行**

![image-20210830104953215](https://img-blog.csdnimg.cn/img_convert/7b4666307ca7855d4e9894c3f6cc7627.png)

3、**共享**（前提是具有并发性）：操作系统中的资源可供多个并发的程序共同使用，这种形式称之为**资源共享**

- **互斥共享**：当资源被程序占用时，其它想使用的程序只能等待。
- **同时访问**：某种资源**并发的**被多个程序访问。

4、**虚拟**：表现为把一个物理实体转变为若干个逻辑实体。

+ **时分复用技术**：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。
+ **空分复用技术**：虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。

5、**异步**（前提是具有并发性）：由于资源限制，进程的执行以“停停走走”的方式运行，而且每个进程**执行的情况**（运行、暂停、速度、完成）也是**未知的**。

## 单道批处理和多道批处理

1、单道批处理：在这种系统中，任意时刻只允许一个作业在内存中并处于执行状态，这种方式的优点是实现简单，但效率低

2、多道批处理：在这种系统中，允许多个作业同时驻留在内存，这些作业可以并发执行，提高了 CPU  的利用率，但系统吞吐量提升，且需要更复杂的调度算法和作业管理机制



## 分时系统和实时系统

**分时系统**：分时系统是多用户操作系统的一种，它允许多个用户通过终端与计算机交互，共享计算机资源

特征：

1、**多路性**：系统允许用户将多台终端同时连接到同一个主机上

2、**独立性**：每个用户在自己的终端上进行操作，给用户独占主机的感觉

3、**及时性**：用户请求在很短时间内可以得到响应

4、**交互性**：用户可以通过终端与系统进行对话

**实时系统**：实时系统是为了控制或者监视某个过程、设备而设计的，它需要在严格的时间约束下对输入做出反应或者控制，对实时性要求很高

特征：**多路性**、**独立性**、**及时性**、**交互性**、**可靠性**





## 中断与异常

中断分为内中断（异常或陷阱）和外中断（中断）

**内中断**是指来自 CPU  和内存内部的中断，包括程序运算引起的错误：**地址非法**、**校验错**、**页面失效**、**指令非法**、**用户自行中断**、**除数为0**、**存储保护错**等

**外中断**是由CPU执行以外的事件所引发的，通常涉及到硬件设备的输入/输出操作，常见的有：**输入/输出设备中断**、**硬件故障或者错误**、**外部信号中断**、**DMA 传输完成中断**

**中断机制**的作用：为了在多道批处理系统中让用户进行交互，实现进程之间的切换

中断处理需要保存**程序状态寄存器**的内容

### 中断产生

- 发生中断时，CPU立马**切换到管态**，开展管理工作；（管态又叫内核态，特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）
- 发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；
- 对于不同的中断信号，会进行不同的处理。

## 用户态和内核态

在**内核态**下系统可以执行非特权指令和特权指令（能引起系统损害的机器指令），在**用户态**下只能执行非特权指令，只能访问当前运行进程的地址空间，能够有效保护 OS 内核及内存中的其他用户程序不受侵害。

# 进程管理

## 进程实体

### 为什么需要进程

1、进程是系统进行**资源分配和调度的基本单位**（定义）

2、进程作为程序独立运行的载体保障程序正常运行

3、进程能够提高系统资源利用率



### 进程特征

1、**动态性**（最基本特征）：生命期

2、**并发性**：一段时间内同时运行

3、**独立性**：进程实体是一个能够独立运行的基本单位

4、**异步性**：进程按异步方式进行	



### 进程控制块（PCB）

是用于描述和控制进程运行的记录型数据结构，记录进程当前状态和控制进程运行的全部信息，**是进程存在的唯一标识**

**PCB 的作用**：

1、作为独立运行基本单位的标志

2、能实现间断性运行方式

3、提供进程管理和调度的信息

4、实现和其他进程的同步和通信



### 进程（Process）和线程（Thread）

+ **进程**：是系统进行**资源分配和调度**的基本单位
+ **线程**：是系统进行运行调度的最小单位

**区别**：

1. **一个进程可以有一个或多个线程**；
2. **线程包含在进程之中，是进程中实际运行工作的单位**；
3. **进程的线程共享进程资源**；
4. **一个进程可以并发多个线程，每个线程执行不同的任务**。

![image-20210826153718544](https://img-blog.csdnimg.cn/img_convert/57105faf208a76086d4ae131c69d5cc0.png)



## 进程状态

**就绪状态**：其他资源（进程控制块，内存，栈空间，堆空间等）都准备好，只差 CPU 的状态

**执行状态**：进程获得 CPU ，某程序正在执行

**阻塞状态**：进程因为某种原因放弃 CPU 的状态，阻塞进程以队列的形式放置

**创建状态**：创建进程时拥有 PCB 但其他资源尚未就绪

**终止状态**：进程结束由系统清理或归还 PCB 的状态

![image-20210830134139425](https://img-blog.csdnimg.cn/img_convert/eeeced482c7813085c3c196d08dda843.png)

## 线程状态

1、**执行状态**

2、**就绪状态**

3、**阻塞状态**



### 线程控制块（TCB）

将所有用于控制和管理线程的信息均记录在 TCB 中



## 挂起操作

1、终端用户的需要：终端用户可挂起进程进行修改

2、父进程的需要：父进程可以考察和修改子进程

3、负荷调节的需要：复合调节较重，将不必要进程挂起

4、OS 的需要：便于检查资源使用情况

**挂起操作引入后的基本状态的转换**：

（1）**活动就绪（内存中）** -> **静止就绪（外存中）**：未被挂起的就绪状态称为活动就绪（Readya），挂起的称为静止就绪（Readys），不会被调度执行

（2）**活动阻塞（内存中）** -> **静止阻塞（外存中）**

（3）**静止就绪** -> **活动就绪**：处于 Readys 的进程，激活后变为 Readya

（4）**静止阻塞** -> **活动阻塞**



## 进程同步



### 四个原则

1、**空闲让进**：资源无占用，允许使用    

2、**忙则等待**：资源被占用，请求进程等待

3、**有限等待**：保证有效等待时间能够使用资源，进入自己的临界区

4、**让权等待**：等待时，进程让出 CPU 



### 临界资源和临界区

临界资源是指一次仅允许一个进程（线程）使用的资源，例如某个变量 i （逻辑资源），打印机（物理资源）等

临界区是指并发执行的过程中，访问临界资源必须互斥执行的程序段



### 进程同步和互斥关系

1、**同步**：多个并发进程（线程）协同完成一项任务时，由于数据交换需要而在进程（线程）执行次序上的约束关系，叫同步关系。

2、**互斥**：并发进程（线程）间为竞争统一资源而间接发生的相互制约关系，叫互斥关系。例如两个进程同时需要完成打印任务，描述的就是互斥关系。



### 信号量机制

信号量机制是一种进程同步的工具

1、**整型信号量**：整型信号量被定义为一个用于表示资源数目的整型量S，它只能被两个标准的原语wait(S)和signal(S)来访问，分别被称为为“**P**”操作（申请一个资源）和“**V**“操作（用于释放资源），它们中的操作都是**原子操作**。

```c++
// S 是一个信号量
void wait(S) {
	while (S <= 0);		// 若此时 S <= 0，申请资源的进程就会在此处一直处于忙等状态
	S = S - 1;
}

void signal(S) {
    S = S + 1
}
```

2、**记录型信号量**

```c++
void wait(semaphore S) { //这里的S是一个结构体
    --S.value;	//value为记录资源数目的变量
    if(S.value < 0)	//注意这里的判断条件是<0
    	block(S.L);	//将申请资源的进程阻塞并添加到等待队列中，程序计数器定位到wait操作后
}

void signal(semaphore S) {
    ++S.value;
    if(S.value <= 0) //注意这里的判断条件是<=0
    	wake(S.L);	//唤醒队首等待的进程，唤醒后执行wait后的代码
}

typedef struct{  
    int value; 			//大于0时表示资源数量，小于0时它的绝对值表示已阻塞的进程数目  
    struct process *L;  //进程阻塞队列
} semaphore;

```

3、**AND 型信号量**（一个进程同时获取多个资源）

```c++
void Swait(S1, S2, ... , Sn) {
     if (S1>=1 && S2>=1 && ... && Sn>=1)  //进程需要访问的资源是否全都可用
         for (int i=1; i<n; i++)
             Si = Si - 1;
     else 
         //自我阻塞，将当前进程放置阻塞队列中
}
 
void Ssignal(S1, S2, ... , Sn) {
     for (int i=1; i<n; i++)
         Si = Si + 1;	//同时唤醒等待队列中的所有进程
}

```





### 管程机制

一个管程定义了一个数据结构和能力为并发进程所执行（在该数据结构上）的一组操作，能够同步进程和改变管程中的数据，这组数据只能被一个进程在一个特定的时刻访问

管程由四部分组成：管程名称、共享数据结构说明、对数据结构进行操作的一组过程、初始化语句

原则：1、共享数据私有化 	2、互斥执行



### 生产者-消费者问题

### 哲学家进餐问题

### 读者-写者问题



**进程同步的作用**：对竞争资源在多进程间进行使用次序的协调，使得**并发执行的多个进程之间可以有效使用资源和相互合作**



# 作业管理

## 进程调度

定义：计算机通过决策决定哪个就绪进程可以**获得 CPU 使用权**

## 什么时候需要进程调度？

1. 主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（如等待I/O）；
2. 被动放弃：分给进程的时间片用完；有更高优先级的进程进入就绪队列；有更紧急的事情需要处理（如I/O中断）；

## 进程调度方式

**非抢占式调度**：只能由当前运行的进程**主动放弃 CPU**

- 处理器一旦分配给某个进程，就让该进程一直使用下去；
- 调度程序不以任何原因抢占正在被使用的处理器；

**抢占式调度**：可由**操作系统剥夺当前进程的 CPU 使用权**

- 允许调度程序以一定的策略暂停当前运行的进程；
- 保存好旧进程的上下文信息，分配处理器给新进程；

![image-20210826162907842](https://img-blog.csdnimg.cn/img_convert/9ea74c5ba75d56e5dc61e331360c18ba.png)

## 进程调度的机制

**就绪队列的排队机制**：为提高进程调度的效率，将就绪进程按照一定的方式进行排列，以便调度程序可以最快找到就绪进程

![
](https://img-blog.csdnimg.cn/img_convert/8ed76cec475f253d2839b4580e736072.png)

**选择运行进程的委派机制**：调度程序以一定的策略，选择就绪进程，将 CPU 资源进行分配

****

**新老进程的上下文切换机制**：保存当前进程的上下文信息，装入被委派进程的运行上下文

![image-20210830141949702](https://img-blog.csdnimg.cn/img_convert/bbf60b6226739b4a3b160ca5dc508e5c.png)



## 进程调度算法

1、**先来先服务算法（FCFS）**：按照在**就绪队列中的先后顺序**执行

2、**短作业优先调度算法（SJF）**：优先选择就绪队列中**运行时间最短的进程**，不利于长作业进程的执行

3、**优先级调度算法**：进程附带优先权，**优先选择权重高的进程**

4、**时间片轮转调度算法（RR）**：按照FIFO的原则排列就绪进程，每次从队列头部取出待执行进程，**分配一个时间片执行**



## 死锁

### 进程死锁、饥饿、死循环的区别

**死锁**：**两个或两个以上的进程**在执行过程中，**由于竞争资源**或者**由于彼此通信**而造成的一种**阻塞**的现象，若无外力作用，它们都将无法推进下去。永远在互相等待的进程称为死锁进程。

**饥饿**：由于长期**得不到资源**导致进程无法推进；

**死循环**：代码逻辑BUG



### 死锁的四个必要条件

1、**互斥条件**：**必须互斥使用资源才会产生死锁**

2、**请求和保持条件**：**进程至少保持一个资源**，又提出新的资源请求，新资源被占用，**请求被阻塞**，被阻塞的进程不释放自己保持的资源

3、**不可抢占条件**：进程获得的资源在未完成使用前不能被抢占（包括OS），**只能由进程自身释放**

4、**循环等待条件**：发生死锁时，必然存在进程-资源环形链,环路等待不一定造成死锁，但是死锁一定有循环等待



### 死锁的处理方法

**一、预防死锁的办法**：破坏四个必要条件中的一个

1、**破坏互斥条件**：将**临界资源改造成共享资源**

2、**破坏请求保持条件**：系统规定进程运行之前，**一次性申请所有需要的资源**

3、**破坏不可抢占条件**：当一个进程请求新的资源得不到满足时，必须**释放占有的资源**

4、**破坏循环等待条件**：可用**资源线性排序**，申请必须按照需要递增申请



**二、银行家算法**：检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源；

例：

进程	最大需求(max)	已分配(allocation)	最多还需要(need)
P0	（7,5,3）	          （0,1,0）	（7,4,3）
P1	（3,2,2）	          （2,0,0）	（1,2,2）
P2	（9,0,2）	          （3,0,2）	（6,0,0）
P3	（2,2,2）	          （2,1,1）	（0,1,1）
P4	（4,3,3）	          （0,0,2）	（4,3,1）
资源总数为（10,5,7），剩余可用资源（3,3,2）。

答：

先用剩余可用资源与最多还需要资源数一 一比较，将剩余可用资源分配给可以完成的进程。

与 P0 比较，（7,4,3）>（3,3,2）

与 P1 比较，（1,2,2）<（3,3,2），P1 进程可以完成，P1 结束归还资源，剩余可用资源增加到（5,3,2）（+ allocation）。

与 P2 比较，（6,0,0）>（5,3,2）

与 P3 比较，（0,1,1）<（5,3,2），剩余可用资源增加到（7,4,3）。

再与 P0 比较，（7,4,3） = （7,4,3），剩余可用资源增加到（7,5,3）。

再与 P2 比较，（6,0,0）< （7,5,3），剩余可用资源增加到（10,5,5）。

与 P4 比较，（4,3,1）<（10,5,5），剩余可用资源增加到（10,5,7）。

最后可找出一个安全序列：{P1, P3, P0, P2, P4}。

注意：每一轮检查都是从编号较小的进程开始检查。



**死锁的检测与解除**：

1、**检测**：死锁检测算法

2、**解除**：资源剥夺法（抢占资源），撤销进程法（终止进程法）



















