#  操作系统概述

## 定义

控制管理计算机系统的硬软件，分配调度资源的**系统软件**

目标：方便性，有效性（提高系统资源利用率），可扩充，开放性

## 基本功能

1、**统一管理计算机资源**

2、**实现对计算机资源的抽象**

3、**提供用户和计算机之间的接口**



# 基本类型

分为批处理系统、分时系统、实时系统



## 基本特征

1、**并行**：两个或多个事件在**同一时刻**发生，多核 CPU 可以实现并行，单核 CPU 同一时刻只有一个程序在运行

2、**并发**：两个或多个事件在**同一时间间隔**发生，每个程序**交替执行**

![image-20210830104953215](https://img-blog.csdnimg.cn/img_convert/7b4666307ca7855d4e9894c3f6cc7627.png)

3、**共享**（前提是具有并发性）：操作系统中的资源可供多个并发的程序共同使用，这种形式称之为**资源共享**

- **互斥共享**：当资源被程序占用时，其它想使用的程序只能等待。
- **同时访问**：某种资源**并发的**被多个程序访问。

4、**虚拟**：表现为把一个物理实体转变为若干个逻辑实体。

+ **时分复用技术**：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。
+ **空分复用技术**：虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。

5、**异步**（前提是具有并发性）：由于资源限制，进程的执行以“停停走走”的方式运行，而且每个进程**执行的情况**（运行、暂停、速度、完成）也是**未知的**。

## 单道批处理和多道批处理

1、单道批处理：在这种系统中，任意时刻只允许一个作业在内存中并处于执行状态，这种方式的优点是实现简单，但效率低

2、多道批处理：在这种系统中，允许多个作业同时驻留在内存，这些作业可以并发执行，提高了 CPU  的利用率，但系统吞吐量提升，且需要更复杂的调度算法和作业管理机制



## 分时系统和实时系统

**分时系统**：分时系统是多用户操作系统的一种，它允许多个用户通过终端与计算机交互，共享计算机资源

特征：

1、**多路性**：系统允许用户将多台终端同时连接到同一个主机上

2、**独立性**：每个用户在自己的终端上进行操作，给用户独占主机的感觉

3、**及时性**：用户请求在很短时间内可以得到响应

4、**交互性**：用户可以通过终端与系统进行对话

**实时系统**：实时系统是为了控制或者监视某个过程、设备而设计的，它需要在严格的时间约束下对输入做出反应或者控制，对实时性要求很高

特征：**多路性**、**独立性**、**及时性**、**交互性**、**可靠性**





## 中断与异常

中断分为内中断（异常或陷阱）和外中断（中断）

**内中断**是指来自 CPU  和内存内部的中断，包括程序运算引起的错误：**地址非法**、**校验错**、**页面失效**、**指令非法**、**用户自行中断**、**除数为0**、**存储保护错**等

**外中断**是由CPU执行以外的事件所引发的，通常涉及到硬件设备的输入/输出操作，常见的有：**输入/输出设备中断**、**硬件故障或者错误**、**外部信号中断**、**DMA 传输完成中断**

**中断机制**的作用：为了在多道批处理系统中让用户进行交互，实现进程之间的切换

中断处理需要保存**程序状态寄存器**的内容

### 中断产生

- 发生中断时，CPU立马**切换到管态**，开展管理工作；（管态又叫内核态，特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）
- 发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；
- 对于不同的中断信号，会进行不同的处理。

## 用户态和内核态

在**内核态**下系统可以执行非特权指令和特权指令（能引起系统损害的机器指令），在**用户态**下只能执行非特权指令，只能访问当前运行进程的地址空间，能够有效保护 OS 内核及内存中的其他用户程序不受侵害。

# 进程管理

## 进程实体

一个完整的进程实体由**程序段**、**相关数据段**、**PCB**三部分组成

### 为什么需要进程

1、进程是系统进行**资源分配和调度的基本单位**（定义）

2、进程作为程序独立运行的载体保障程序正常运行

3、进程能够提高系统资源利用率



### 进程特征

1、**动态性**（最基本特征）：生命期

2、**并发性**：一段时间内同时运行

3、**独立性**：进程实体是一个能够独立运行的基本单位

4、**异步性**：进程按异步方式进行	



### 进程控制块（PCB）

是用于描述和控制进程运行的记录型数据结构，记录进程当前状态和控制进程运行的全部信息，**是进程存在的唯一标识**

**PCB 的作用**：

1、作为独立运行基本单位的标志

2、能实现间断性运行方式

3、提供进程管理和调度的信息

4、实现和其他进程的同步和通信



### 进程（Process）和线程（Thread）

**传统** OS 中：**进程**是系统**资源分配和调度**的基本单位

**引入线程**的 OS 中：**线程**作为资源调度和分配的基本单位，**进程**是一个可拥有资源的基本单位



**区别**：

1. **一个进程可以有一个或多个线程**；
2. **线程包含在进程之中，是进程中实际运行工作的单位**；
3. **进程的线程共享进程资源**；
4. **一个进程可以并发多个线程，每个线程执行不同的任务**。（同一进程中的各线程共享该进程的虚拟地址空间）

![image-20210826153718544](https://img-blog.csdnimg.cn/img_convert/57105faf208a76086d4ae131c69d5cc0.png)

## 进程和程序

1、进程是程序的执行过程，代表执行中的程序

2、**一对一**：执行一条命令或一个应用程序时，是一对一的关系

3、**一对多**：进程在执行过程中可以加载执行不同的应用程序，形成一对多的关系

4、**多对一**：进程以不同的参数或数据多次执行同一个程序时，形成多对一的关系

5、**多对多**：并发执行不同的应用程序时，形成多对多的关系



## 进程状态

**就绪状态**：其他资源（进程控制块，内存，栈空间，堆空间等）都准备好，只差 CPU 的状态

**执行状态**：进程获得 CPU ，某程序正在执行

**阻塞状态**：进程因为某种原因放弃 CPU 的状态，阻塞进程以队列的形式放置（等待协作进程的一个消息）

**创建状态**：创建进程时拥有 PCB 但其他资源尚未就绪

**终止状态**：进程结束由系统清理或归还 PCB 的状态

![image-20210830134139425](https://img-blog.csdnimg.cn/img_convert/eeeced482c7813085c3c196d08dda843.png)

---

**注意**：处于就绪状态的进程分配 CPU 之后不一定能够进入执行状态，还取决于优先级，调度策略等因素



## 进程通信

### 管道（Pipe）

1、管道实际上是一种大小固定的缓冲区，对于管道两端的进程而言，就是一个文件

2、管道只存在内存中，容量大小不受磁盘容量大小的限制

3、一个管道可以实现双向传输，但是同一时刻只能够在一个方向上进行传输，进程对管道进行读写操作时可能会发生阻塞，当管道空时，读操作会阻塞，当管道满时，写操作会阻塞

4、管道通信是以自然字符流为单位进行写入和读出的





## 线程状态

1、**执行状态**

2、**就绪状态**

3、**阻塞状态**



### 线程控制块（TCB）

将所有用于控制和管理线程的信息均记录在 TCB 中



## 线程的实现方式

1、**内核支持线程**：调度是在内核中由 OS 完成

2、**用户级线程**（效率更高）：因为可以只在用户空间内进行，可以在不支持内核支持线程的 OS 上实现

**两种线程的组合方式**：

1、**一对一**

2、**多对一**：多个用户级线程对应一个内核支持线程

3、**多对多**



## 挂起操作

1、终端用户的需要：终端用户可挂起进程进行修改

2、父进程的需要：父进程可以考察和修改子进程

3、负荷调节的需要：复合调节较重，将不必要进程挂起

4、OS 的需要：便于检查资源使用情况

**挂起操作引入后的基本状态的转换**：

（1）**活动就绪（内存中）** -> **静止就绪（外存中）**：未被挂起的就绪状态称为活动就绪（Readya），挂起的称为静止就绪（Readys），不会被调度执行（**内存资源无法满足需求**）

（2）**活动阻塞（内存中）** -> **静止阻塞（外存中）**

（3）**静止就绪** -> **活动就绪**：处于 Readys 的进程，激活后变为 Readya

（4）**静止阻塞** -> **活动阻塞**





## 进程同步



### 四个原则

1、**空闲让进**：资源无占用，允许使用    

2、**忙则等待**：资源被占用，请求进程等待

3、**有限等待**：保证有效等待时间能够使用资源，进入自己的临界区

4、**让权等待**：等待时，进程让出 CPU 



### 临界资源和临界区

临界资源是指一次仅允许一个进程（线程）使用的资源，例如某个变量 i （逻辑资源），打印机（物理资源）等

临界区是指并发执行的过程中，访问临界资源必须互斥执行的程序段



### 进程同步和互斥关系

1、**同步**：多个并发进程（线程）协同完成一项任务时，由于数据交换需要而在进程（线程）执行次序上的约束关系，叫同步关系。

2、**互斥**：并发进程（线程）间为竞争统一资源而间接发生的相互制约关系，叫互斥关系。例如两个进程同时需要完成打印任务，描述的就是互斥关系。



### 信号量机制

信号量机制是一种进程同步的工具

1、**整型信号量**：整型信号量被定义为一个用于表示资源数目的整型量S，它只能被两个标准的原语wait(S)和signal(S)来访问，分别被称为为“**P**”操作（申请一个资源）和“**V**“操作（用于释放资源），它们中的操作都是**原子操作**。

```c++
// S 是一个信号量
void wait(S) {
	while (S <= 0);		// 若此时 S <= 0，申请资源的进程就会在此处一直处于忙等状态
	S = S - 1;
}

void signal(S) {
    S = S + 1
}
```

2、**记录型信号量**

```c++
void wait(semaphore S) { //这里的S是一个结构体
    --S.value;	//value为记录资源数目的变量
    if(S.value < 0)	//注意这里的判断条件是<0
    	block(S.L);	//将申请资源的进程阻塞并添加到等待队列中，程序计数器定位到wait操作后
}

void signal(semaphore S) {
    ++S.value;
    if(S.value <= 0) //注意这里的判断条件是<=0
    	wake(S.L);	//唤醒队首等待的进程，唤醒后执行wait后的代码
}

typedef struct{  
    int value; 			//大于0时表示资源数量，小于0时它的绝对值表示已阻塞的进程数目  
    struct process *L;  //进程阻塞队列
} semaphore;

```

3、**AND 型信号量**（一个进程同时获取多个资源）

```c++
void Swait(S1, S2, ... , Sn) {
     if (S1>=1 && S2>=1 && ... && Sn>=1)  //进程需要访问的资源是否全都可用
         for (int i=1; i<n; i++)
             Si = Si - 1;
     else 
         //自我阻塞，将当前进程放置阻塞队列中
}
 
void Ssignal(S1, S2, ... , Sn) {
     for (int i=1; i<n; i++)
         Si = Si + 1;	//同时唤醒等待队列中的所有进程
}

```





### 管程机制

一个管程定义了一个数据结构和能力为并发进程所执行（在该数据结构上）的一组操作，能够同步进程和改变管程中的数据，这组数据只能被一个进程在一个特定的时刻访问

管程由四部分组成：管程名称、共享数据结构说明、对数据结构进行操作的一组过程、初始化语句

原则：1、共享数据私有化 	2、互斥执行



### 生产者-消费者问题

### 哲学家进餐问题

### 读者-写者问题



**进程同步的作用**：对竞争资源在多进程间进行使用次序的协调，使得**并发执行的多个进程之间可以有效使用资源和相互合作**



# 作业管理

## 进程调度

定义：计算机通过决策决定哪个就绪进程可以**获得 CPU 使用权**

## 什么时候需要进程调度？

1. 主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（如等待I/O）；
2. 被动放弃：分给进程的时间片用完；有更高优先级的进程进入就绪队列；有更紧急的事情需要处理（如I/O中断）；

## 进程调度方式

**非抢占式调度**：只能由当前运行的进程**主动放弃 CPU**

- 处理器一旦分配给某个进程，就让该进程一直使用下去；
- 调度程序不以任何原因抢占正在被使用的处理器；

**抢占式调度**：可由**操作系统剥夺当前进程的 CPU 使用权**

- 允许调度程序以一定的策略暂停当前运行的进程；
- 保存好旧进程的上下文信息，分配处理器给新进程；

![image-20210826162907842](https://img-blog.csdnimg.cn/img_convert/9ea74c5ba75d56e5dc61e331360c18ba.png)

## 进程调度的机制

**就绪队列的排队机制**：为提高进程调度的效率，将就绪进程按照一定的方式进行排列，以便调度程序可以最快找到就绪进程

![
](https://img-blog.csdnimg.cn/img_convert/8ed76cec475f253d2839b4580e736072.png)

**选择运行进程的委派机制**：调度程序以一定的策略，选择就绪进程，将 CPU 资源进行分配

****

**新老进程的上下文切换机制**：保存当前进程的上下文信息，装入被委派进程的运行上下文

![image-20210830141949702](https://img-blog.csdnimg.cn/img_convert/bbf60b6226739b4a3b160ca5dc508e5c.png)



## 进程调度算法

1、**先来先服务算法（FCFS）**：按照在**就绪队列中的先后顺序**执行

2、**短作业优先调度算法（SJF）**（平均周转时间最短）：优先选择就绪队列中**运行时间最短的进程**，不利于长作业进程的执行

3、**优先级调度算法**：进程附带优先权，**优先选择权重高的进程**

4、**高响应比优先算法**（兼顾了长作业，实现了 FCFS）：优先级（响应比） = （等待时间 + 服务时间）/ 服务时间

5、**时间片轮转调度算法（RR）**：按照FIFO的原则排列就绪进程，每次从队列头部取出待执行进程，**分配一个时间片执行**

+ 若一个时间片尚未用完而正在运行的进程已完成，就进行下一个进程
+ 若时间片用完，但进程未执行运行完毕，则将该进程放至就绪队列的末尾

周转时间 = 完成时间 - 到达时间（提交时间）

带权周转时间 = 周转时间 / 服务时间



## 死锁

### 进程死锁、饥饿、死循环的区别

**死锁**：**两个或两个以上的进程**在执行过程中，**由于竞争资源**或者**由于彼此通信**而造成的一种**阻塞**的现象，若无外力作用，它们都将无法推进下去。永远在互相等待的进程称为死锁进程。

**饥饿**：由于长期**得不到资源**导致进程无法推进；

**死循环**：代码逻辑BUG



### 死锁的四个必要条件

1、**互斥条件**：**必须互斥使用资源才会产生死锁**

2、**请求和保持条件**：**进程至少保持一个资源**，又提出新的资源请求，新资源被占用，**请求被阻塞**，被阻塞的进程不释放自己保持的资源

3、**不可抢占条件**：进程获得的资源在未完成使用前不能被抢占（包括OS），**只能由进程自身释放**

4、**循环等待条件**：发生死锁时，必然存在进程-资源环形链,环路等待不一定造成死锁，但是死锁一定有循环等待



### 死锁的处理方法

**一、预防死锁的办法**：破坏四个必要条件中的一个

1、**破坏互斥条件**：将**临界资源改造成共享资源**

2、**破坏请求保持条件**：系统规定进程运行之前，**一次性申请所有需要的资源**

3、**破坏不可抢占条件**：当一个进程请求新的资源得不到满足时，必须**释放占有的资源**

4、**破坏循环等待条件**：可用**资源线性排序**，申请必须按照需要递增申请



**二、银行家算法**：检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源；

例：

进程	最大需求(max)	已分配(allocation)	最多还需要(need)
P0	（7,5,3）	          （0,1,0）	（7,4,3）
P1	（3,2,2）	          （2,0,0）	（1,2,2）
P2	（9,0,2）	          （3,0,2）	（6,0,0）
P3	（2,2,2）	          （2,1,1）	（0,1,1）
P4	（4,3,3）	          （0,0,2）	（4,3,1）
资源总数为（10,5,7），剩余可用资源（3,3,2）。

答：

先用剩余可用资源与最多还需要资源数一 一比较，将剩余可用资源分配给可以完成的进程。

与 P0 比较，（7,4,3）>（3,3,2）

与 P1 比较，（1,2,2）<（3,3,2），P1 进程可以完成，P1 结束归还资源，剩余可用资源增加到（5,3,2）（+ allocation）。

与 P2 比较，（6,0,0）>（5,3,2）

与 P3 比较，（0,1,1）<（5,3,2），剩余可用资源增加到（7,4,3）。

再与 P0 比较，（7,4,3） = （7,4,3），剩余可用资源增加到（7,5,3）。

再与 P2 比较，（6,0,0）< （7,5,3），剩余可用资源增加到（10,5,5）。

与 P4 比较，（4,3,1）<（10,5,5），剩余可用资源增加到（10,5,7）。

最后可找出一个安全序列：{P1, P3, P0, P2, P4}。

注意：每一轮检查都是从编号较小的进程开始检查。



**死锁的检测与解除**：

1、**检测**：死锁检测算法

2、**解除**：资源剥夺法（抢占资源），撤销进程法（终止进程法）





# 虚拟存储器



## 常见存储器管理方式的特征

+ 一次性：作业必须一次性装入内存后才可运行
+ 驻留性：作业被装入内存后，整个作业驻留在内存中，其中任何部分不会被换出，直到作业运行结束

**一次性和驻留性不是必要的	**



## 局部性原理

在一段较短的时间内，程序的执行仅仅**局限于某个部分**

+ 时间局限性：程序的某条指令被执行，不久后可能再次执行，因为程序中存在大量的**循环操作**

+ 空间局限性

  

## 虚拟存储器的基本工作情况

 ```c
 基于局部性原理可知，应用程序在运行之前没有必要将之全部装入内存，而仅须将那些当前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上。  //部分装入内存
 ```



```c
    程序在运行时，如果它所要访问的页已调入内存，便可继续执行下去；但如果程序所要访问的页尚未调入内存(称为缺页或缺段)，便发出缺页中断请求，此时 OS 将利用请求调页功能将它们调入内存，以使进程能继续执行下去。如果此时内存已满，无法再装入新的页，OS 还须再利用页的置换功能，将内存中暂时不用的页调至盘上，腾出足够的内存空间后，再将要访问的页调入内存，使程序继续执行下去。  //缺页 -> 缺页中断 -> 内存满 -> 页面置换
```


## 虚拟存储器的实现方法

### 分页请求系统

在分页系统的基础上增加了**请求调页功能**和**页面置换功能**形成的页式虚拟存储系统

**请求页表机制**

![img](https://img-blog.csdnimg.cn/9986a993e8c448fca0fb7aaaa98d8470.png)

+ 状态位P：指示该页是否已调入内存	

+ 访问字段A：记录本页在一段时间内被访问的次数，提供给置换算法在**选择换出页面**时参考

+ 修改位M：标识该页在调入内存后是否被修改过，若修改过，就要重写到外存上，保证外存的副本时最新的

+ 外存地址：用于指出该页在外存上的地址，通常时**物理块号**



















